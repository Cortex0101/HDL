package HDL;

import ANTLR.HDLLexer;
import ANTLR.HDLParser;
import ANTLR.HDLParser.ANDContext;
import ANTLR.HDLParser.AssignContext;
import ANTLR.HDLParser.CMDHardwareContext;
import ANTLR.HDLParser.CMDInputsContext;
import ANTLR.HDLParser.CMDLatchContext;
import ANTLR.HDLParser.CMDOutputsContext;
import ANTLR.HDLParser.CMDSimulateContext;
import ANTLR.HDLParser.CMDUpdateContext;
import ANTLR.HDLParser.ConstantContext;
import ANTLR.HDLParser.InstantiateContext;
import ANTLR.HDLParser.NOTContext;
import ANTLR.HDLParser.ORContext;
import ANTLR.HDLParser.ParenthesesContext;
import ANTLR.HDLParser.StartContext;
import ANTLR.HDLParser.VariableContext;
import ANTLR.HDLVisitor;
import java.io.IOException;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.AbstractParseTreeVisitor;
import org.antlr.v4.runtime.tree.ParseTree;

public class Main {
  public static void main(String[] args) throws IOException {
    // we expect exactly one argument: the name of the input file
    if (args.length!=1) {
      System.err.println("\n");
      System.err.println("Impl Interpreter\n");
      System.err.println("=================\n\n");
      System.err.println("Please give as input argument a filename\n");
      System.exit(-1);
    }
    String filename=args[0];

    // open the input file
    CharStream input = CharStreams.fromFileName("D:\\Development\\Projects\\HDL\\src\\main\\resources\\" + filename);

    // create a lexer/scanner
    HDLLexer lex = new HDLLexer(input);

    // get the stream of tokens from the scanner
    CommonTokenStream tokens = new CommonTokenStream(lex);

    // create a parser
    HDLParser parser = new HDLParser(tokens);

    // and parse anything from the grammar for "start"
    ParseTree parseTree = parser.start();

    System.out.println(parseTree.toStringTree());

    // Construct an interpreter and run it on the parse tree
    Interpreter interpreter = new Interpreter();
    Expr result = interpreter.visit(parseTree);
    System.out.println("Result is: " + result.eval(new Environment()));
  }
}

// We write an interpreter that implements interface
// "implVisitor<T>" that is automatically generated by ANTLR
// This is parameterized over a return type "<T>" which is in our case
// simply a Double.

class Interpreter extends AbstractParseTreeVisitor<Expr> implements HDLVisitor<Expr> {
  public Expr visitStart(StartContext ctx) {
    return visit(ctx.e1);
  }

  @Override
  public Expr visitVariable(VariableContext ctx) {
    return new Variable(ctx.x.getText());
  }

  @Override
  public Expr visitOR(ORContext ctx) {
    return new OR(visit(ctx.e1), visit(ctx.e2));
  }

  @Override
  public Expr visitConstant(ConstantContext ctx) {
    return new Constant(Boolean.parseBoolean(ctx.c.getText()));
  }

  @Override
  public Expr visitCMDSimulate(CMDSimulateContext ctx) {
    return null;
  }

  @Override
  public Expr visitCMDOutputs(CMDOutputsContext ctx) {
    return null;
  }

  @Override
  public Expr visitNOT(NOTContext ctx) {
    return new NOT(visit(ctx.e1));
  }

  @Override
  public Expr visitCMDHardware(CMDHardwareContext ctx) {
    return null;
  }

  @Override
  public Expr visitCMDUpdate(CMDUpdateContext ctx) {
    return null;
  }

  @Override
  public Expr visitAND(ANDContext ctx) {
    return new AND(visit(ctx.e1), visit(ctx.e2));
  }

  @Override
  public Expr visitAssign(AssignContext ctx) {
    return null;
  }

  @Override
  public Expr visitInstantiate(InstantiateContext ctx) {
    return null;
  }

  @Override
  public Expr visitCMDInputs(CMDInputsContext ctx) {
    return null;
  }

  @Override
  public Expr visitParentheses(ParenthesesContext ctx) {
    return visit(ctx.e1);
  }

  @Override
  public Expr visitCMDLatch(CMDLatchContext ctx) {
    return null;
  }
}

